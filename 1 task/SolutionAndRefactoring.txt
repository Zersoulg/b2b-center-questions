Оптимизируйте таблицы и запрос при необходимости.

1) По моему мнению, хранение телефонных номеров в другой таблице избыточно. Если не стоит задачи дальнейшего
расширения этой таблицы (судя по названию - нет), то лучше хранить телефонные номера в таблице users (правила нормализации)

2) Решения для выбора типов данных я тоже считаю избыточным
    а) id - в обеих таблицах стоит добавить параметр UNSIGNED, т.к. id не может быть отрицательным
    б) varchar(255) name может оказаться как слишком малым, так и слишком большим количеством. Зависит от бизнес-задачи: у
    меня были прецеденты в опыте работы, когда этого количества было мало, но обычно этого стандарта хватает.
    Стоит также разнести поле name на суб-поля, например, имя, фамилия, ник и так далее. Зависит от бизнес-задач.
    в) int(11) gender очень избыточен.
        в1) Не во всех БД поддерживается BOOLEAN (синоним tinyint(1)), однако если он поддерживается, можно хранить
            в этом значении, а "не указан" в виде NULL.
        в2) если база не нагружена, а нам критичен как можно более простой вывод информации (чем проще запросы для
            написания, тем лучше), можно использовать ENUM. Но это чревато огромными дублирующимися данными
        б3) если вдруг работа на Запад, то там возможны другие гендеры (друг работает на фрилансе, показывал подобный кейс).
            Тогда можно вынести гендер в отдельную таблицу с возможным расширением в дальнейшем, а в поле хранить foreign key
    г) я пока ещё ни разу в практике не встречал преимущества хранения даты как INT. Тип данных datetime присутствует почти
        во всех БД, он уже оптимизирован под вывод и обработку информации. Однако, MySQL преобразует строку или int в timestamp
        налету (в других бд пока что не довелось попробовать этот кейс), ну или при помощи таких функций, как CAST.
    д) user_id стоит указать как foreign key для лучшего взаимодействия (индексы всегда помогают оптимизировать запросы),
        а также unsigned
    е) phone - тема для холивара, как хранить. Полностью ли с пробелами и скобками, с + в начале или нет, с пробелами
        и/или дефисами. Но varchar(255) для телефона явно избыточно, можно хранить в int(20) (вроде, именно такой
        набор с кодом страны может быть самым длинным)

3) не совсем понял, как я могу оптимизировать запрос, если мне же его и нужно составить. Единственное, после
объединения таблиц, нам не нужно будет использовать u.id = pn.user_id

4) по запросу:
    Условимся, что работаем с данной задачей. Таблице две, в запросе нужно вывести количество записей из второй таблицы.
    а) Используем left join, чтобы взять информацию из первой таблицы (name, birthday, gender)
    б) birthday по сути - число, можем использовать BETWEEN (хотя если бы хранили в datetime, запрос тоже бы прошёл).
    Главное, чтобы элементы в BETWEEN были одного типа, значит нужно перевести их в UNIX_TIMESTAMP. ДЛя наглядности получения
    даты рождения, соответствующему возрасту 22 и 18 лет, я просто вычитал из текущего времени (now()) интервал. На скорость особо не
    влияет, но запрос становится сильно нагляднее.
    в) Сгруппируем по id телефона, чтобы не получить всего одну строчку вывода (тогда count() будет считаться по всем строчкам)

    Если таблица будет одна, то запрос будет идентичный, кроме конечно же join'а


Для решения пользовался SQL Fiddle для проверки синтаксиса
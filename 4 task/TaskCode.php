<?php

/**
 * Проведите рефакторинг, исправьте баги и продокументируйте в стиле PHPDoc код, приведённый ниже (таблица users здесь аналогична таблице users из задачи №1).
 * Примечание: код написан исключительно в тестовых целях, это не "жизненный пример" :)
 * function load_users_data($user_ids) {
 *      $user_ids = explode(',', $user_ids);
 *
 *      foreach ($user_ids as $user_id) {
 *          $db = mysqli_connect("localhost", "root", "123123", "database");
 *          $sql = mysqli_query($db, "SELECT * FROM users WHERE id=$user_id");
 *
 *          while($obj = $sql->fetch_object()) {
 *              $data[$user_id] = $obj->name;
 *          }
 *
 *      mysqli_close($db);
 *      }
 *      return $data;
 * }
 *
 * Как правило, в $_GET['user_ids'] должна приходить строка
 * с номерами пользователей через запятую, например: 1,2,17,48
 *
 * $data = load_users_data($_GET['user_ids']);
 * foreach ($data as $user_id=>$name) {
 *      echo "<a href=\"/show_user.php?id=$user_id\">$name</a>";
 * }
 *
 * Плюсом будет, если укажете, какие именно уязвимости присутствуют в исходном варианте (если таковые, на ваш взгляд, имеются), и приведёте примеры их проявления.
 *
 */
class TaskCode {

    /**
     * Честности ради, даже не знаю, как в рамках этой задачи можно использовать PHPDoc
     * @param string $userIds
     *
     * @return mixed
     */
    public function load_users_data($userIds) {
        // я привык давать имена переменным в ЯП в стиле camelCase, исключение - магические методы, дающие доступ
        // к строкам в БД, там как правило under_score

        // Странно, что нам приходят данные с сепаратором запятой вместо массива, но будем работать с этим

        // Нельзя делать инициализацию подключения к БД в цикле. Она должна быть одна, не стоит лишний раз нагружать
        // базу, если это не требуется
        $db = mysqli_connect("localhost", "root", "123123", "database");

        // Зачем делать несколько запросов, когда есть IN
        // Т.к. синтаксис оператора IN - параметры через запятую, то нам и не нужно делать explode
        // В итоге нам нужны только name и id, вместо * укажем их
        // Мало того, что запросы в цикле, так ещё и в двойном цикле. За нас и так всё сделает БД и драйвер.
        $result = mysqli_query($db, "SELECT id, name FROM users WHERE id IN ($userIds)")->fetch_all();

        //И только сейчас закрываем коннект к базе! Вообще желательно это делать в конце метода, где используется коннект,
        // но в рамках этой задачи закрытия в методе getUsers() не требуется
        mysqli_close($db);

        return $result;
    }

    /**
     * @throws Exception
     * @return void
     */
    public function getUsers(): void {
        $userIds = $_GET['user_ids'] ?? null;

        // из $_GET мы можем получить всё что угодно, никогда не стоит доверять пользователям. Хоть у нас и нет никакой
        // обёртки от SQL-инъекций (с приходом фреймворков эти уязвимости канули в Лету), лучше перепроверить вручную
        // Допускаю, что у mysqli есть функционал биндинга параметров

        // Проверить можем таким способом: мы ожидаем int. Сделаем проверочный explode здесь, и проверим данные на int
        $userIdsArray = explode(',', $userIds);
        foreach ($userIdsArray as $userId) {
            // filter_var работает как parseInt в Java или JS. Мы хотя бы сможем вытащить числа из данной строки.
            // Но всё ещё остаётся опасность, что пользователь сможет получить UserId, к которому у него не должно быть доступа
            if (filter_var($userId, FILTER_VALIDATE_INT) === false ) {
                // Достаточно RuntimeException. 400 - стандартный код неправильной валидации. Однако, парадигма может быть
                // такая, что даже на ошибку мы выдаём 200 - вопросы безопасности и тема для холивара
                throw new RuntimeException('Variables in user_ids should be an integer', 400);
            }
        }

        $data = $this->load_users_data($_GET['user_ids']);

        foreach ($data as $userData) {
            // Здесь кроме нейминга и првоерки на наличие параметра в массиве ничего не нужно менять
            if (isset($userData['id'], $userData['name'])) {
                // Возможно, стоит воспользоваться библиотекой из первого задания для формирования URL.
                // JS-инъекции тоже стоит учитывать, а там, где URL или формочки, там и может случиться беда
                echo '<a href=/show_user.php?id=' . $userData['id'] . '\"> ' . $userData['name'] . '</a>';
            }
        }
    }
}